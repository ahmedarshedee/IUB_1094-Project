{
  "version": 3,
  "sources": ["../../rate-limiter-flexible/lib/RateLimiterAbstract.js", "../../rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js", "../../rate-limiter-flexible/lib/component/BlockedKeys/index.js", "../../rate-limiter-flexible/lib/RateLimiterRes.js", "../../rate-limiter-flexible/lib/RateLimiterStoreAbstract.js", "../../rate-limiter-flexible/lib/RateLimiterRedis.js", "../../rate-limiter-flexible/lib/RateLimiterMongo.js", "../../rate-limiter-flexible/lib/RateLimiterMySQL.js", "../../rate-limiter-flexible/lib/RateLimiterPostgres.js", "browser-external:cluster", "browser-external:crypto", "../../rate-limiter-flexible/lib/component/MemoryStorage/Record.js", "../../rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js", "../../rate-limiter-flexible/lib/RateLimiterMemory.js", "../../rate-limiter-flexible/lib/RateLimiterCluster.js", "../../rate-limiter-flexible/lib/RateLimiterMemcache.js", "../../rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js", "../../rate-limiter-flexible/lib/RateLimiterUnion.js", "../../rate-limiter-flexible/lib/component/RateLimiterQueueError.js", "../../rate-limiter-flexible/lib/RateLimiterQueue.js", "../../rate-limiter-flexible/lib/BurstyRateLimiter.js", "../../rate-limiter-flexible/lib/RateLimiterDynamo.js", "../../rate-limiter-flexible/lib/RateLimiterPrisma.js", "../../rate-limiter-flexible/index.js"],
  "sourcesContent": ["module.exports = class RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   points: 4, // Number of points\n   *   duration: 1, // Per seconds\n   *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds\n   *   execEvenly: false, // Execute allowed actions evenly over duration\n   *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option\n   *   keyPrefix: 'rlflx',\n   * }\n   */\n  constructor(opts = {}) {\n    this.points = opts.points;\n    this.duration = opts.duration;\n    this.blockDuration = opts.blockDuration;\n    this.execEvenly = opts.execEvenly;\n    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;\n    this.keyPrefix = opts.keyPrefix;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  set points(value) {\n    this._points = value >= 0 ? value : 4;\n  }\n\n  get duration() {\n    return this._duration;\n  }\n\n  set duration(value) {\n    this._duration = typeof value === 'undefined' ? 1 : value;\n  }\n\n  get msDuration() {\n    return this.duration * 1000;\n  }\n\n  get blockDuration() {\n    return this._blockDuration;\n  }\n\n  set blockDuration(value) {\n    this._blockDuration = typeof value === 'undefined' ? 0 : value;\n  }\n\n  get msBlockDuration() {\n    return this.blockDuration * 1000;\n  }\n\n  get execEvenly() {\n    return this._execEvenly;\n  }\n\n  set execEvenly(value) {\n    this._execEvenly = typeof value === 'undefined' ? false : Boolean(value);\n  }\n\n  get execEvenlyMinDelayMs() {\n    return this._execEvenlyMinDelayMs;\n  }\n\n  set execEvenlyMinDelayMs(value) {\n    this._execEvenlyMinDelayMs = typeof value === 'undefined' ? Math.ceil(this.msDuration / this.points) : value;\n  }\n\n  get keyPrefix() {\n    return this._keyPrefix;\n  }\n\n  set keyPrefix(value) {\n    if (typeof value === 'undefined') {\n      value = 'rlflx';\n    }\n    if (typeof value !== 'string') {\n      throw new Error('keyPrefix must be string');\n    }\n    this._keyPrefix = value;\n  }\n\n  _getKeySecDuration(options = {}) {\n    return options && options.customDuration >= 0\n      ? options.customDuration\n      : this.duration;\n  }\n\n  getKey(key) {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;\n  }\n\n  parseKey(rlKey) {\n    return rlKey.substring(this.keyPrefix.length);\n  }\n\n  consume() {\n    throw new Error(\"You have to implement the method 'consume'!\");\n  }\n\n  penalty() {\n    throw new Error(\"You have to implement the method 'penalty'!\");\n  }\n\n  reward() {\n    throw new Error(\"You have to implement the method 'reward'!\");\n  }\n\n  get() {\n    throw new Error(\"You have to implement the method 'get'!\");\n  }\n\n  set() {\n    throw new Error(\"You have to implement the method 'set'!\");\n  }\n\n  block() {\n    throw new Error(\"You have to implement the method 'block'!\");\n  }\n\n  delete() {\n    throw new Error(\"You have to implement the method 'delete'!\");\n  }\n};\n", "module.exports = class BlockedKeys {\n  constructor() {\n    this._keys = {}; // {'key': 1526279430331}\n    this._addedKeysAmount = 0;\n  }\n\n  collectExpired() {\n    const now = Date.now();\n\n    Object.keys(this._keys).forEach((key) => {\n      if (this._keys[key] <= now) {\n        delete this._keys[key];\n      }\n    });\n\n    this._addedKeysAmount = Object.keys(this._keys).length;\n  }\n\n  /**\n   * Add new blocked key\n   *\n   * @param key String\n   * @param sec Number\n   */\n  add(key, sec) {\n    this.addMs(key, sec * 1000);\n  }\n\n  /**\n   * Add new blocked key for ms\n   *\n   * @param key String\n   * @param ms Number\n   */\n  addMs(key, ms) {\n    this._keys[key] = Date.now() + ms;\n    this._addedKeysAmount++;\n    if (this._addedKeysAmount > 999) {\n      this.collectExpired();\n    }\n  }\n\n  /**\n   * 0 means not blocked\n   *\n   * @param key\n   * @returns {number}\n   */\n  msBeforeExpire(key) {\n    const expire = this._keys[key];\n\n    if (expire && expire >= Date.now()) {\n      this.collectExpired();\n      const now = Date.now();\n      return expire >= now ? expire - now : 0;\n    }\n\n    return 0;\n  }\n\n  /**\n   * If key is not given, delete all data in memory\n   * \n   * @param {string|undefined} key\n   */\n  delete(key) {\n    if (key) {\n      delete this._keys[key];\n    } else {\n      Object.keys(this._keys).forEach((key) => {\n        delete this._keys[key];\n      });\n    }\n  }\n};\n", "const BlockedKeys = require('./BlockedKeys');\n\nmodule.exports = BlockedKeys;\n", "module.exports = class RateLimiterRes {\n  constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {\n    this.remainingPoints = typeof remainingPoints === 'undefined' ? 0 : remainingPoints; // Remaining points in current duration\n    this.msBeforeNext = typeof msBeforeNext === 'undefined' ? 0 : msBeforeNext; // Milliseconds before next action\n    this.consumedPoints = typeof consumedPoints === 'undefined' ? 0 : consumedPoints; // Consumed points in current duration\n    this.isFirstInDuration = typeof isFirstInDuration === 'undefined' ? false : isFirstInDuration;\n  }\n\n  get msBeforeNext() {\n    return this._msBeforeNext;\n  }\n\n  set msBeforeNext(ms) {\n    this._msBeforeNext = ms;\n    return this;\n  }\n\n  get remainingPoints() {\n    return this._remainingPoints;\n  }\n\n  set remainingPoints(p) {\n    this._remainingPoints = p;\n    return this;\n  }\n\n  get consumedPoints() {\n    return this._consumedPoints;\n  }\n\n  set consumedPoints(p) {\n    this._consumedPoints = p;\n    return this;\n  }\n\n  get isFirstInDuration() {\n    return this._isFirstInDuration;\n  }\n\n  set isFirstInDuration(value) {\n    this._isFirstInDuration = Boolean(value);\n  }\n\n  _getDecoratedProperties() {\n    return {\n      remainingPoints: this.remainingPoints,\n      msBeforeNext: this.msBeforeNext,\n      consumedPoints: this.consumedPoints,\n      isFirstInDuration: this.isFirstInDuration,\n    };\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this._getDecoratedProperties();\n  }\n\n  toString() {\n    return JSON.stringify(this._getDecoratedProperties());\n  }\n\n  toJSON() {\n    return this._getDecoratedProperties();\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0)\n      && res.consumedPoints >= this.inMemoryBlockOnConsumed\n    ) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res)\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + changedPoints)) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise\n        .then(() => {\n          reject(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options)\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((res) => {\n          reject(res);\n        });\n    }\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, -points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options)\n        .then((res) => {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(this._getRateLimiterRes(rlKey, 0, res));\n          }\n        })\n        .catch((err) => {\n          this._handleError(err, 'get', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options)\n        .then((res) => {\n          this._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'delete', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options)\n        .then(() => {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        })\n        .catch((err) => {\n          this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n        });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\n\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    this.client = opts.storeClient;\n\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n    this._incrTtlLuaScript = opts.customIncrTtlLuaScript || incrTtlLuaScript;\n\n    this.useRedisPackage = opts.useRedisPackage || this.client.constructor.name === 'Commander' || false;\n    this.useRedis3AndLowerPackage = opts.useRedis3AndLowerPackage;\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: this._incrTtlLuaScript,\n      });\n    }\n  }\n\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    }\n    // ioredis client\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    }\n    // node-redis client\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n    return true;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result;\n    // Support ioredis results format\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n\n    return res;\n  }\n\n  async _upsert(rlKey, points, msDuration, forceExpire = false) {\n    if (!this._isRedisReady()) {\n      throw new Error('Redis connection is not ready');\n    }\n\n    const secDuration = Math.floor(msDuration / 1000);\n    const multi = this.client.multi();\n\n    if (forceExpire) {\n      if (secDuration > 0) {\n        if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n          multi.set(rlKey, points, \"EX\", secDuration);\n        }else{\n          multi.set(rlKey, points, { EX: secDuration });\n        }\n      } else {\n        multi.set(rlKey, points);\n      }\n\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return multi.pttl(rlKey).exec(true);\n      }\n      return multi.pTTL(rlKey).exec(true);\n    }\n\n    if (secDuration > 0) {\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return this.client.rlflxIncr(\n          [rlKey].concat([String(points), String(secDuration), String(this.points), String(this.duration)]));\n      }\n      if (this.useRedis3AndLowerPackage) {\n        return new Promise((resolve, reject) => {\n          const incrCallback = function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(result);\n          };\n\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, this.points, this.duration, incrCallback);\n          } else {\n            this.client.eval(this._incrTtlLuaScript, 1, rlKey, points, secDuration, this.points, this.duration, incrCallback);\n          }\n        });\n      } else {\n        return this.client.eval(this._incrTtlLuaScript, {\n          keys: [rlKey],\n          arguments: [String(points), String(secDuration), String(this.points), String(this.duration)],\n        });\n      }\n    } else {\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return multi.incrby(rlKey, points).pttl(rlKey).exec(true);\n      }\n\n      return multi.incrBy(rlKey, points).pTTL(rlKey).exec(true);\n    }\n  }\n\n  async _get(rlKey) {\n    if (!this._isRedisReady()) {\n      throw new Error('Redis connection is not ready');\n    }\n    if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n      return this.client\n        .multi()\n        .get(rlKey)\n        .pttl(rlKey)\n        .exec()\n        .then((result) => {\n          const [[,points]] = result;\n          if (points === null) return null;\n          return result;\n        });\n    }\n\n    return this.client\n      .multi()\n      .get(rlKey)\n      .pTTL(rlKey)\n      .exec(true)\n      .then((result) => {\n        const [points] = result;\n        if (points === null) return null;\n        return result;\n      });\n  }\n\n  _delete(rlKey) {\n    return this.client\n      .del(rlKey)\n      .then(result => result > 0);\n  }\n}\n\nmodule.exports = RateLimiterRedis;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n\n    let _v = [0, 0, 0];\n    if (typeof _client.topology === 'undefined') {\n      const { version } = _client.options.metadata.driver;\n      _v = version.split('|', 1)[0].split('.').map(v => parseInt(v));\n    } else {\n      const { version } = _client.topology.s.options.metadata.driver;\n      _v = version.split('.').map(v => parseInt(v));\n    }\n\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2],\n    };\n  } catch (err) {\n    return { major: 0, feature: 0, patch: 0 };\n  }\n}\n\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client\n        .then((conn) => {\n          this.client = conn;\n          this._initCollection();\n          this._driverVersion = getDriverVersion(this.client);\n        });\n    } else {\n      this._initCollection();\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n    this._client = value;\n  }\n\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n\n  _initCollection() {\n    const db = typeof this.client.db === 'function'\n      ? this.client.db(this.dbName)\n      : this.client;\n\n    const collection = db.collection(this.tableName);\n    collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });\n\n    this._collection = collection;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n\n    let doc;\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null\n      ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    let where;\n    let upsertData;\n    if (forceExpire) {\n      where = { key };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [\n          { expire: { $gt: new Date() } },\n          { expire: { $eq: null } },\n        ],\n        key,\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n        $inc: { points },\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    }\n\n    // Options for collection updates differ between driver versions\n    const upsertOptions = {\n      upsert: true,\n    };\n    if ((this._driverVersion.major >= 4) ||\n        (this._driverVersion.major === 3 &&\n          (this._driverVersion.feature >=7) || \n          (this._driverVersion.feature >= 6 && \n              this._driverVersion.patch >= 7 ))) \n    {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(\n        where,\n        upsertData,\n        upsertOptions\n      ).then((res) => {\n        resolve(res);\n      }).catch((errUpsert) => {\n        if (errUpsert && errUpsert.code === 11000) { // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({ // try to replace OLD limit doc\n            $or: [\n              { expire: { $lte: new Date() } },\n              { expire: { $eq: null } },\n            ],\n            key,\n          }, docAttrs);\n\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n            }, docAttrs)\n          };\n\n          this._collection.findOneAndUpdate(\n            replaceWhere,\n            replaceTo,\n            upsertOptions\n          ).then((res) => {\n            resolve(res);\n          }).catch((errReplace) => {\n            if (errReplace && errReplace.code === 11000) { // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire)\n                .then(res => resolve(res))\n                .catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n\n  _get(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    const where = Object.assign({\n      key: rlKey,\n      $or: [\n        { expire: { $gt: new Date() } },\n        { expire: { $eq: null } },\n      ],\n    }, docAttrs);\n\n    return this._collection.findOne(where);\n  }\n\n  _delete(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({ key: rlKey }, docAttrs);\n\n    return this._collection.deleteOne(where)\n      .then(res => res.deletedCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterMongo;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMySQL extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: anySqlClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   dbName: 'string',\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createDbAndTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {\n            this._releaseConnection(conn);\n            resolve();\n          });\n        })\n        .catch(() => {\n          resolve();\n        });\n    });\n  }\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return new Promise((resolve, reject) => {\n          this.client.getConnection((errConn, conn) => {\n            if (errConn) {\n              return reject(errConn);\n            }\n\n            resolve(conn);\n          });\n        });\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return conn.release();\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createDbAndTable() {\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`CREATE DATABASE IF NOT EXISTS \\`${this.dbName}\\`;`, (errDb) => {\n            if (errDb) {\n              this._releaseConnection(conn);\n              return reject(errDb);\n            }\n            conn.query(this._getCreateTableStmt(), (err) => {\n              if (err) {\n                this._releaseConnection(conn);\n                return reject(err);\n              }\n              this._releaseConnection(conn);\n              resolve();\n            });\n          });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS \\`${this.dbName}\\`.\\`${this.tableName}\\` (` +\n      '`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,' +\n      '`points` INT(9) NOT NULL default 0,' +\n      '`expire` BIGINT UNSIGNED,' +\n      'PRIMARY KEY (`key`)' +\n      ') ENGINE = INNODB;';\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    if (typeof value === 'undefined') {\n      if (this.client.constructor.name === 'Connection') {\n        value = 'connection';\n      } else if (this.client.constructor.name === 'Pool') {\n        value = 'pool';\n      } else if (this.client.constructor.name === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n    this._clientType = value.toLowerCase();\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? 'rtlmtrflx' : value;\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const [row] = result;\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsertTransaction(conn, key, points, msDuration, forceExpire) {\n    return new Promise((resolve, reject) => {\n      conn.query('BEGIN', (errBegin) => {\n        if (errBegin) {\n          conn.rollback();\n\n          return reject(errBegin);\n        }\n\n        const dateNow = Date.now();\n        const newExpire = msDuration > 0 ? dateNow + msDuration : null;\n\n        let q;\n        let values;\n        if (forceExpire) {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = ?, \n            expire = ?;`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            points,\n            newExpire,\n          ];\n        } else {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = IF(expire <= ?, ?, points + (?)), \n            expire = IF(expire <= ?, ?, expire);`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            dateNow, points, points,\n            dateNow, newExpire,\n          ];\n        }\n\n        conn.query(q, values, (errUpsert) => {\n          if (errUpsert) {\n            conn.rollback();\n\n            return reject(errUpsert);\n          }\n          conn.query('SELECT points, expire FROM ??.?? WHERE `key` = ?;', [this.dbName, this.tableName, key], (errSelect, res) => {\n            if (errSelect) {\n              conn.rollback();\n\n              return reject(errSelect);\n            }\n\n            conn.query('COMMIT', (err) => {\n              if (err) {\n                conn.rollback();\n\n                return reject(err);\n              }\n\n              resolve(res);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          this._upsertTransaction(conn, key, points, msDuration, forceExpire)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)',\n            [this.dbName, this.tableName, rlKey, Date.now()],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else if (res.length === 0) {\n                resolve(null);\n              } else {\n                resolve(res);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'DELETE FROM ??.?? WHERE `key` = ?',\n            [this.dbName, this.tableName, rlKey],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(res.affectedRows > 0);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMySQL;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   *   schemaName: 'string', // optional\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.tableName = opts.tableName;\n    this.schemaName = opts.schemaName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  _getTableIdentifier() {\n    return this.schemaName ? `\"${this.schemaName}\".\"${this.tableName}\"` : `\"${this.tableName}\"`;\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this._getTableIdentifier()} WHERE expire < $1`,\n        values: [expire],\n      };\n      this._query(q)\n        .then(() => {\n          resolve();\n        })\n        .catch(() => {\n          // Deleting expired query is not critical\n          resolve();\n        });\n    });\n  }\n\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      case 'typeorm':\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt(),\n      })\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          if (err.code === '23505') {\n            // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n            // Postgres doesn't handle concurrent table creation\n            // It is supposed, that table is created by another worker\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this._getTableIdentifier()} (\n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (\n        constructorName === 'Pool' ||\n        constructorName === 'BoundPool'\n      ) {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get schemaName() {\n    return this._schemaName;\n  }\n\n  set schemaName(value) {\n    this._schemaName = value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated;\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(queryObj)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire\n      ? ' $3 '\n      : ` CASE\n             WHEN ${this._getTableIdentifier()}.expire <= $4 THEN $3\n             ELSE ${this._getTableIdentifier()}.expire\n            END `;\n\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this._getTableIdentifier()} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this._getTableIdentifier()}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this._getTableIdentifier()}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()],\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this._getTableIdentifier()} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()],\n      })\n        .then((res) => {\n          if (res.rowCount === 0) {\n            res = null;\n          }\n          resolve(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this._getTableIdentifier()} WHERE key = $1`,\n      values: [rlKey],\n    })\n      .then(res => res.rowCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterPostgres;\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"cluster\" has been externalized for browser compatibility. Cannot access \"cluster.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"crypto\" has been externalized for browser compatibility. Cannot access \"crypto.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = class Record {\n  /**\n   *\n   * @param value int\n   * @param expiresAt Date|int\n   * @param timeoutId\n   */\n  constructor(value, expiresAt, timeoutId = null) {\n    this.value = value;\n    this.expiresAt = expiresAt;\n    this.timeoutId = timeoutId;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this._value = parseInt(value);\n  }\n\n  get expiresAt() {\n    return this._expiresAt;\n  }\n\n  set expiresAt(value) {\n    if (!(value instanceof Date) && Number.isInteger(value)) {\n      value = new Date(value);\n    }\n    this._expiresAt = value;\n  }\n\n  get timeoutId() {\n    return this._timeoutId;\n  }\n\n  set timeoutId(value) {\n    this._timeoutId = value;\n  }\n};\n", "const Record = require('./Record');\nconst RateLimiterRes = require('../../RateLimiterRes');\n\nmodule.exports = class MemoryStorage {\n  constructor() {\n    /**\n     * @type {Object.<string, Record>}\n     * @private\n     */\n    this._storage = {};\n  }\n\n  incrby(key, value, durationSec) {\n    if (this._storage[key]) {\n      const msBeforeExpires = this._storage[key].expiresAt\n        ? this._storage[key].expiresAt.getTime() - new Date().getTime()\n        : -1;\n      if (!this._storage[key].expiresAt || msBeforeExpires > 0) {\n        // Change value\n        this._storage[key].value = this._storage[key].value + value;\n\n        return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);\n      }\n\n      return this.set(key, value, durationSec);\n    }\n    return this.set(key, value, durationSec);\n  }\n\n  set(key, value, durationSec) {\n    const durationMs = durationSec * 1000;\n\n    if (this._storage[key] && this._storage[key].timeoutId) {\n      clearTimeout(this._storage[key].timeoutId);\n    }\n\n    this._storage[key] = new Record(\n      value,\n      durationMs > 0 ? new Date(Date.now() + durationMs) : null\n    );\n    if (durationMs > 0) {\n      this._storage[key].timeoutId = setTimeout(() => {\n        delete this._storage[key];\n      }, durationMs);\n      if (this._storage[key].timeoutId.unref) {\n        this._storage[key].timeoutId.unref();\n      }\n    }\n\n    return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);\n  }\n\n  /**\n   *\n   * @param key\n   * @returns {*}\n   */\n  get(key) {\n    if (this._storage[key]) {\n      const msBeforeExpires = this._storage[key].expiresAt\n        ? this._storage[key].expiresAt.getTime() - new Date().getTime()\n        : -1;\n      return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);\n    }\n    return null;\n  }\n\n  /**\n   *\n   * @param key\n   * @returns {boolean}\n   */\n  delete(key) {\n    if (this._storage[key]) {\n      if (this._storage[key].timeoutId) {\n        clearTimeout(this._storage[key].timeoutId);\n      }\n      delete this._storage[key];\n      return true;\n    }\n    return false;\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor(opts = {}) {\n    super(opts);\n\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const secDuration = this._getKeySecDuration(options);\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)\n    );\n  }\n\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)\n    );\n  }\n\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n\n    return Promise.resolve(res);\n  }\n\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n}\n\nmodule.exports = RateLimiterMemory;\n\n", "/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration,\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix, // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data,\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts,\n    },\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise\n      .then((res) => {\n        masterSendToWorker(worker, msg, 'resolve', res);\n      })\n      .catch((rejRes) => {\n        masterSendToWorker(worker, msg, 'reject', rejRes);\n      });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(\n        msg.data.remainingPoints,\n        msg.data.msBeforeNext,\n        msg.data.consumedPoints,\n        msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix,\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs),\n  };\n\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    cluster.setMaxListeners(0);\n\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix,\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', (packet) => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix,\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: (msgData) => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            },\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor(opts = {}) {\n    super(opts);\n\n    process.setMaxListeners(0);\n\n    this.timeoutMs = opts.timeoutMs;\n\n    this._initiated = false;\n\n    process.on('message', (msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this),\n    });\n\n    this._promises = {};\n  }\n\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker,\n};\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemcache extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: memcacheClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.client = opts.storeClient;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(result.consumedPoints);\n    res.isFirstInDuration = result.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = result.msBeforeNext;\n\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n      const secDuration = Math.floor(msDuration / 1000);\n\n      if (forceExpire) {\n        this.client.set(rlKey, points, secDuration, (err) => {\n          if (!err) {\n            this.client.set(\n              `${rlKey}_expire`,\n              secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n              secDuration,\n              () => {\n                const res = {\n                  consumedPoints: points,\n                  msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                };\n                resolve(res);\n              }\n            );\n          } else {\n            reject(err);\n          }\n        });\n      } else {\n        this.client.incr(rlKey, points, (err, consumedPoints) => {\n          if (err || consumedPoints === false) {\n            this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {\n              if (errAddKey || !createdNew) {\n                // Try to upsert again in case of race condition\n                if (typeof options.attemptNumber === 'undefined' || options.attemptNumber < 3) {\n                  const nextOptions = Object.assign({}, options);\n                  nextOptions.attemptNumber = nextOptions.attemptNumber ? (nextOptions.attemptNumber + 1) : 1;\n\n                  this._upsert(rlKey, points, msDuration, forceExpire, nextOptions)\n                    .then(resUpsert => resolve(resUpsert))\n                    .catch(errUpsert => reject(errUpsert));\n                } else {\n                  reject(new Error('Can not add key'));\n                }\n              } else {\n                this.client.add(\n                  `${rlKey}_expire`,\n                  secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n                  secDuration,\n                  () => {\n                    const res = {\n                      consumedPoints: points,\n                      msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                    };\n                    resolve(res);\n                  }\n                );\n              }\n            });\n          } else {\n            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n              if (errGetExpire) {\n                reject(errGetExpire);\n              } else {\n                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n                const res = {\n                  consumedPoints,\n                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n                };\n                resolve(res);\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n\n      this.client.get(rlKey, (err, consumedPoints) => {\n        if (!consumedPoints) {\n          resolve(null);\n        } else {\n          this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n            if (errGetExpire) {\n              reject(errGetExpire);\n            } else {\n              const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n              const res = {\n                consumedPoints,\n                msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n              };\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else if (res === false) {\n          resolve(res);\n        } else {\n          this.client.del(`${rlKey}_expire`, (errDelExpire) => {\n            if (errDelExpire) {\n              reject(errDelExpire);\n            } else {\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMemcache;\n", "const RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RLWrapperBlackAndWhite {\n  constructor(opts = {}) {\n    this.limiter = opts.limiter;\n    this.blackList = opts.blackList;\n    this.whiteList = opts.whiteList;\n    this.isBlackListed = opts.isBlackListed;\n    this.isWhiteListed = opts.isWhiteListed;\n    this.runActionAnyway = opts.runActionAnyway;\n  }\n\n  get limiter() {\n    return this._limiter;\n  }\n\n  set limiter(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('limiter is not set');\n    }\n\n    this._limiter = value;\n  }\n\n  get runActionAnyway() {\n    return this._runActionAnyway;\n  }\n\n  set runActionAnyway(value) {\n    this._runActionAnyway = typeof value === 'undefined' ? false : value;\n  }\n\n  get blackList() {\n    return this._blackList;\n  }\n\n  set blackList(value) {\n    this._blackList = Array.isArray(value) ? value : [];\n  }\n\n  get isBlackListed() {\n    return this._isBlackListed;\n  }\n\n  set isBlackListed(func) {\n    if (typeof func === 'undefined') {\n      func = () => false;\n    }\n    if (typeof func !== 'function') {\n      throw new Error('isBlackListed must be function');\n    }\n    this._isBlackListed = func;\n  }\n\n  get whiteList() {\n    return this._whiteList;\n  }\n\n  set whiteList(value) {\n    this._whiteList = Array.isArray(value) ? value : [];\n  }\n\n  get isWhiteListed() {\n    return this._isWhiteListed;\n  }\n\n  set isWhiteListed(func) {\n    if (typeof func === 'undefined') {\n      func = () => false;\n    }\n    if (typeof func !== 'function') {\n      throw new Error('isWhiteListed must be function');\n    }\n    this._isWhiteListed = func;\n  }\n\n  isBlackListedSomewhere(key) {\n    return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);\n  }\n\n  isWhiteListedSomewhere(key) {\n    return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);\n  }\n\n  getBlackRes() {\n    return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);\n  }\n\n  getWhiteRes() {\n    return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);\n  }\n\n  rejectBlack() {\n    return Promise.reject(this.getBlackRes());\n  }\n\n  resolveBlack() {\n    return Promise.resolve(this.getBlackRes());\n  }\n\n  resolveWhite() {\n    return Promise.resolve(this.getWhiteRes());\n  }\n\n  consume(key, pointsToConsume = 1) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.rejectBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.consume(key, pointsToConsume);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.consume(key, pointsToConsume).catch(() => {});\n    }\n    return res;\n  }\n\n  block(key, secDuration) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.block(key, secDuration);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.block(key, secDuration).catch(() => {});\n    }\n    return res;\n  }\n\n  penalty(key, points) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.penalty(key, points);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.penalty(key, points).catch(() => {});\n    }\n    return res;\n  }\n\n  reward(key, points) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.reward(key, points);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.reward(key, points).catch(() => {});\n    }\n    return res;\n  }\n\n  get(key) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined' || this.runActionAnyway) {\n      return this.limiter.get(key);\n    }\n\n    return res;\n  }\n\n  delete(key) {\n    return this.limiter.delete(key);\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\n\nmodule.exports = class RateLimiterUnion {\n  constructor(...limiters) {\n    if (limiters.length < 1) {\n      throw new Error('RateLimiterUnion: at least one limiter have to be passed');\n    }\n    limiters.forEach((limiter) => {\n      if (!(limiter instanceof RateLimiterAbstract)) {\n        throw new Error('RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract');\n      }\n    });\n\n    this._limiters = limiters;\n  }\n\n  consume(key, points = 1) {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      this._limiters.forEach((limiter) => {\n        promises.push(limiter.consume(key, points).catch(rej => ({ rejected: true, rej })));\n      });\n\n      Promise.all(promises)\n        .then((res) => {\n          const resObj = {};\n          let rejected = false;\n\n          res.forEach((item) => {\n            if (item.rejected === true) {\n              rejected = true;\n            }\n          });\n\n          for (let i = 0; i < res.length; i++) {\n            if (rejected && res[i].rejected === true) {\n              resObj[this._limiters[i].keyPrefix] = res[i].rej;\n            } else if (!rejected) {\n              resObj[this._limiters[i].keyPrefix] = res[i];\n            }\n          }\n\n          if (rejected) {\n            reject(resObj);\n          } else {\n            resolve(resObj);\n          }\n        });\n    });\n  }\n};\n", "module.exports = class RateLimiterQueueError extends Error {\n  constructor(message, extra) {\n    super();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.name = 'CustomError';\n    this.message = message;\n    if (extra) {\n      this.extra = extra;\n    }\n  }\n};\n", "const RateLimiterQueueError = require('./component/RateLimiterQueueError')\nconst MAX_QUEUE_SIZE = 4294967295;\nconst KEY_DEFAULT = 'limiter';\n\nmodule.exports = class RateLimiterQueue {\n  constructor(limiterFlexible, opts = {\n    maxQueueSize: MAX_QUEUE_SIZE,\n  }) {\n    this._queueLimiters = {\n      KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)\n    };\n    this._limiterFlexible = limiterFlexible;\n    this._maxQueueSize = opts.maxQueueSize\n  }\n\n  getTokensRemaining(key = KEY_DEFAULT) {\n    if (this._queueLimiters[key]) {\n      return this._queueLimiters[key].getTokensRemaining()\n    } else {\n      return Promise.resolve(this._limiterFlexible.points)\n    }\n  }\n\n  removeTokens(tokens, key = KEY_DEFAULT) {\n    if (!this._queueLimiters[key]) {\n      this._queueLimiters[key] = new RateLimiterQueueInternal(\n        this._limiterFlexible, {\n          key,\n          maxQueueSize: this._maxQueueSize,\n        })\n    }\n\n    return this._queueLimiters[key].removeTokens(tokens)\n  }\n};\n\nclass RateLimiterQueueInternal {\n\n  constructor(limiterFlexible, opts = {\n    maxQueueSize: MAX_QUEUE_SIZE,\n    key: KEY_DEFAULT,\n  }) {\n    this._key = opts.key;\n    this._waitTimeout = null;\n    this._queue = [];\n    this._limiterFlexible = limiterFlexible;\n\n    this._maxQueueSize = opts.maxQueueSize\n  }\n\n  getTokensRemaining() {\n    return this._limiterFlexible.get(this._key)\n      .then((rlRes) => {\n        return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;\n      })\n  }\n\n  removeTokens(tokens) {\n    const _this = this;\n\n    return new Promise((resolve, reject) => {\n      if (tokens > _this._limiterFlexible.points) {\n        reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));\n        return\n      }\n\n      if (_this._queue.length > 0) {\n        _this._queueRequest.call(_this, resolve, reject, tokens);\n      } else {\n        _this._limiterFlexible.consume(_this._key, tokens)\n          .then((res) => {\n            resolve(res.remainingPoints);\n          })\n          .catch((rej) => {\n            if (rej instanceof Error) {\n              reject(rej);\n            } else {\n              _this._queueRequest.call(_this, resolve, reject, tokens);\n              if (_this._waitTimeout === null) {\n                _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);\n              }\n            }\n          });\n      }\n    })\n  }\n\n  _queueRequest(resolve, reject, tokens) {\n    const _this = this;\n    if (_this._queue.length < _this._maxQueueSize) {\n      _this._queue.push({resolve, reject, tokens});\n    } else {\n      reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`))\n    }\n  }\n\n  _processFIFO() {\n    const _this = this;\n\n    if (_this._waitTimeout !== null) {\n      clearTimeout(_this._waitTimeout);\n      _this._waitTimeout = null;\n    }\n\n    if (_this._queue.length === 0) {\n      return;\n    }\n\n    const item = _this._queue.shift();\n    _this._limiterFlexible.consume(_this._key, item.tokens)\n      .then((res) => {\n        item.resolve(res.remainingPoints);\n        _this._processFIFO.call(_this);\n      })\n      .catch((rej) => {\n        if (rej instanceof Error) {\n          item.reject(rej);\n          _this._processFIFO.call(_this);\n        } else {\n          _this._queue.unshift(item);\n          if (_this._waitTimeout === null) {\n            _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);\n          }\n        }\n      });\n  }\n}\n", "const RateLimiterRes = require(\"./RateLimiterRes\");\n\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\nmodule.exports = class BurstyRateLimiter {\n  constructor(rateLimiter, burstLimiter) {\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter\n  }\n\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n  _combineRes(rlRes, blRes) {\n    if (!rlRes) {\n      return null\n    }\n\n    return new RateLimiterRes(\n      rlRes.remainingPoints,\n      Math.min(rlRes.msBeforeNext, blRes ? blRes.msBeforeNext : 0),\n      rlRes.consumedPoints,\n      rlRes.isFirstInDuration\n    )\n  }\n\n  /**\n   * @param key\n   * @param pointsToConsume\n   * @param options\n   * @returns {Promise<any>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return this._rateLimiter.consume(key, pointsToConsume, options)\n      .catch((rlRej) => {\n        if (rlRej instanceof RateLimiterRes) {\n          return this._burstLimiter.consume(key, pointsToConsume, options)\n            .then((blRes) => {\n              return Promise.resolve(this._combineRes(rlRej, blRes))\n            })\n            .catch((blRej) => {\n                if (blRej instanceof RateLimiterRes) {\n                  return Promise.reject(this._combineRes(rlRej, blRej))\n                } else {\n                  return Promise.reject(blRej)\n                }\n              }\n            )\n        } else {\n          return Promise.reject(rlRej)\n        }\n      })\n  }\n\n  /**\n   * It doesn't expose available points from burstLimiter\n   *\n   * @param key\n   * @returns {Promise<RateLimiterRes>}\n   */\n  get(key) {\n    return Promise.all([\n      this._rateLimiter.get(key),\n      this._burstLimiter.get(key),\n    ]).then(([rlRes, blRes]) => {\n      return this._combineRes(rlRes, blRes);\n    });\n  }\n\n  get points() {\n    return this._rateLimiter.points;\n  }\n};\n", "const RateLimiterRes = require(\"./RateLimiterRes\");\nconst RateLimiterStoreAbstract = require(\"./RateLimiterStoreAbstract\");\n\nclass DynamoItem {\n  /**\n   * Create a DynamoItem.\n   * @param {string} rlKey - The key for the rate limiter.\n   * @param {number} points - The number of points.\n   * @param {number} expire - The expiration time in seconds.\n   */\n  constructor(rlKey, points, expire) {\n    this.key = rlKey;\n    this.points = points;\n    this.expire = expire;\n  }\n}\n\n// Free tier DynamoDB provisioned mode params\nconst DEFAULT_READ_CAPACITY_UNITS = 25;\nconst DEFAULT_WRITE_CAPACITY_UNITS = 25;\n\n/**\n * Implementation of RateLimiterStoreAbstract using DynamoDB.\n * @class RateLimiterDynamo\n * @extends RateLimiterStoreAbstract\n */\nclass RateLimiterDynamo extends RateLimiterStoreAbstract {\n\n    /**\n     * Constructs a new instance of the class.\n     * The storeClient MUST be an instance of AWS.DynamoDB NOT of AWS.DynamoDBClient.\n     *\n     * @param {Object} opts - The options for the constructor.\n     * @param {function} cb - The callback function (optional).\n     * @return {void}\n     */\n    constructor(opts, cb = null) {\n        super(opts);\n\n        this.client = opts.storeClient;\n        this.tableName = opts.tableName;\n        this.tableCreated = opts.tableCreated;\n        \n        if (!this.tableCreated) {\n          this._createTable(opts.dynamoTableOpts)\n          .then((data) => {\n            this.tableCreated = true;\n\n            this._setTTL()\n            .finally(() => {\n              // Callback invocation\n              if (typeof cb === 'function') {\n                cb();\n              }\n            });\n            \n          })\n          .catch( err => {\n            //callback invocation\n            if (typeof cb === 'function') {\n              cb(err);\n            } else {\n              throw err;\n            }\n          });\n\n        } else {\n\n          this._setTTL()\n          .finally(() => {\n            // Callback invocation\n            if (typeof cb === 'function') {\n              cb();\n            }\n          });\n        }\n    }\n\n    get tableName() {\n        return this._tableName;\n    }\n\n    set tableName(value) {\n        this._tableName = typeof value === 'undefined' ? 'node-rate-limiter-flexible' : value;\n    }\n\n    get tableCreated() {\n        return this._tableCreated\n    }\n    \n    set tableCreated(value) {\n        this._tableCreated = typeof value === 'undefined' ? false : !!value;\n    }\n\n    /**\n     * Creates a table in the database. Return null if the table already exists.\n     * \n     * @param {{readCapacityUnits: number, writeCapacityUnits: number}} tableOpts\n     * @return {Promise} A promise that resolves with the result of creating the table.\n     */\n    async _createTable(tableOpts) {\n\n      const params = {\n        TableName: this.tableName,\n        AttributeDefinitions: [\n          {\n            AttributeName: 'key',\n            AttributeType: 'S'\n          }\n        ],\n        KeySchema: [\n          {\n            AttributeName: 'key',\n            KeyType: 'HASH'\n          }\n        ],\n        ProvisionedThroughput: {\n          ReadCapacityUnits: tableOpts && tableOpts.readCapacityUnits ? tableOpts.readCapacityUnits : DEFAULT_READ_CAPACITY_UNITS,\n          WriteCapacityUnits: tableOpts && tableOpts.writeCapacityUnits ? tableOpts.writeCapacityUnits : DEFAULT_WRITE_CAPACITY_UNITS\n        }\n      };\n      \n      try {\n        const data = await this.client.createTable(params);\n        return data;\n      } catch(err) {\n        if (err.__type && err.__type.includes('ResourceInUseException')) {\n          return null;\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    /**\n     * Retrieves an item from the table based on the provided key.\n     *\n     * @param {string} rlKey - The key used to retrieve the item.\n     * @throws {Error} Throws an error if the table is not created yet.\n     * @return {DynamoItem|null} - The retrieved item, or null if it doesn't exist.\n     */\n    async _get(rlKey) {\n\n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n\n      const params = {\n        TableName: this.tableName,\n        Key: {\n          key: {S: rlKey}\n        }\n      };\n      \n      const data = await this.client.getItem(params);\n      if(data.Item) {\n        return new DynamoItem(\n          data.Item.key.S,\n          Number(data.Item.points.N),\n          Number(data.Item.expire.N)\n        );\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Deletes an item from the table based on the given rlKey.\n     *\n     * @param {string} rlKey - The rlKey of the item to delete.\n     * @throws {Error} Throws an error if the table is not created yet.\n     * @return {boolean} Returns true if the item was successfully deleted, otherwise false.\n     */\n    async _delete(rlKey) {\n\n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n\n      const params = {\n        TableName: this.tableName,\n        Key: {\n          key: {S: rlKey}\n        },\n        ConditionExpression: 'attribute_exists(#k)',\n        ExpressionAttributeNames: {\n          '#k': 'key'  \n        }\n      }\n      \n      try {\n        const data = await this._client.deleteItem(params);\n        return data.$metadata.httpStatusCode === 200;\n      } catch(err) {\n        // ConditionalCheckFailed, item does not exist in table\n        if (err.__type && err.__type.includes('ConditionalCheckFailedException')) {\n          return false;\n        } else {\n          throw err;\n        }\n      }\n\n    }\n\n    /**\n     * Implemented with DynamoDB Atomic Counters. 3 calls are made to DynamoDB but each call is atomic.\n     * From the documentation: \"UpdateItem calls are naturally serialized within DynamoDB,\n     * so there are no race condition concerns with making multiple simultaneous calls.\"\n     * See: https://aws.amazon.com/it/blogs/database/implement-resource-counters-with-amazon-dynamodb/\n     * @param {*} rlKey \n     * @param {*} points \n     * @param {*} msDuration \n     * @param {*} forceExpire \n     * @param {*} options \n     * @returns\n     */\n    async _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n\n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n\n      const dateNow = Date.now();\n      const dateNowSec = dateNow / 1000;\n      /* -1 means never expire, DynamoDb do not support null values in number fields.\n         DynamoDb TTL use unix timestamp in seconds.\n      */\n      const newExpireSec = msDuration > 0 ? (dateNow + msDuration) / 1000 : -1;\n\n      // Force expire, overwrite points. Create a new entry if not exists\n      if (forceExpire) {\n        return await this._baseUpsert({\n          TableName: this.tableName,\n          Key: { key: {S: rlKey} },\n          UpdateExpression: 'SET points = :points, expire = :expire',\n          ExpressionAttributeValues: {\n            ':points': {N: points.toString()},\n            ':expire': {N: newExpireSec.toString()}\n          },\n          ReturnValues: 'ALL_NEW'\n        });\n      }\n\n      try {        \n        // First try update, success if entry NOT exists or IS expired\n        return await this._baseUpsert({\n          TableName: this.tableName,\n          Key: { key: {S: rlKey} },\n          UpdateExpression: 'SET points = :new_points, expire = :new_expire',\n          ExpressionAttributeValues: {\n            ':new_points': {N: points.toString()},\n            ':new_expire': {N: newExpireSec.toString()},\n            ':where_expire': {N: dateNowSec.toString()}\n          },\n          ConditionExpression: 'expire <= :where_expire OR attribute_not_exists(points)',\n          ReturnValues: 'ALL_NEW'\n        });\n\n      } catch (err) {\n        // Second try update, success if entry exists and IS NOT expired\n        return await this._baseUpsert({\n          TableName: this.tableName,\n          Key: { key: {S: rlKey} },\n          UpdateExpression: 'SET points = points + :new_points',\n          ExpressionAttributeValues: {\n            ':new_points': {N: points.toString()},\n            ':where_expire': {N: dateNowSec.toString()}\n          },\n          ConditionExpression: 'expire > :where_expire',\n          ReturnValues: 'ALL_NEW'\n        });\n      }\n    }\n    \n    /**\n     * Asynchronously upserts data into the table. params is a DynamoDB params object.\n     *\n     * @param {Object} params - The parameters for the upsert operation.\n     * @throws {Error} Throws an error if the table is not created yet.\n     * @return {DynamoItem} Returns a DynamoItem object with the updated data.\n     */\n    async _baseUpsert(params) {\n\n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n      \n      try {\n        const data = await this.client.updateItem(params);\n        return new DynamoItem(\n          data.Attributes.key.S,\n          Number(data.Attributes.points.N),\n          Number(data.Attributes.expire.N)\n        );\n      } catch (err) {\n        //console.log('_baseUpsert', params, err);\n        throw err;\n      }\n    }\n\n    /**\n     * Sets the Time-to-Live (TTL) for the table. TTL use the expire field in the table.\n     * See: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/howitworks-ttl.html\n     *\n     * @return {Promise} A promise that resolves when the TTL is successfully set.\n     * @throws {Error} Throws an error if the table is not created yet.\n     * @returns {Promise}\n     */\n    async _setTTL() {\n\n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n\n      try {\n        \n        // Check if the TTL is already set\n        const isTTLSet = await this._isTTLSet();\n        if (isTTLSet) {\n          return;\n        }\n\n        const params = {\n          TableName: this.tableName,\n          TimeToLiveSpecification: {\n            AttributeName: 'expire',\n            Enabled: true\n          }\n        }\n\n        const res = await this.client.updateTimeToLive(params);\n        return res;\n\n      } catch (err) {\n        throw err;\n      }\n\n    }\n\n    /**\n     * Checks if the Time To Live (TTL) feature is set for the DynamoDB table.\n     *\n     * @return {boolean} Returns true if the TTL feature is enabled for the table, otherwise false.\n     * @throws {Error} Throws an error if the table is not created yet or if there is an error while checking the TTL status.\n     */\n    async _isTTLSet() {\n      \n      if (!this.tableCreated) {\n        throw new Error('Table is not created yet');\n      }\n\n      try {\n\n        const res = await this.client.describeTimeToLive({TableName: this.tableName});\n        return (\n          res.$metadata.httpStatusCode == 200 \n          && res.TimeToLiveDescription.TimeToLiveStatus === 'ENABLED'\n          && res.TimeToLiveDescription.AttributeName === 'expire'\n        );\n        \n      } catch (err) {\n        throw err;\n      }\n    }\n\n    /**\n     * Generate a RateLimiterRes object based on the provided parameters.\n     *\n     * @param {string} rlKey - The key for the rate limiter.\n     * @param {number} changedPoints - The number of points that have changed.\n     * @param {DynamoItem} result - The result object of _get() method.\n     * @returns {RateLimiterRes} - The generated RateLimiterRes object.\n     */\n    _getRateLimiterRes(rlKey, changedPoints, result) {\n\n      const res = new RateLimiterRes();\n      res.isFirstInDuration = changedPoints === result.points;\n      res.consumedPoints = res.isFirstInDuration ? changedPoints : result.points;\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      // Expire time saved in unix time seconds not ms\n      res.msBeforeNext = result.expire != -1 ? Math.max(result.expire * 1000 - Date.now(), 0) : -1;\n\n      return res;\n    }\n\n}\n\nmodule.exports = RateLimiterDynamo;", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPrisma extends RateLimiterStoreAbstract {\n  /**\n   * Constructor for the rate limiter\n   * @param {Object} opts - Options for the rate limiter\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.modelName = opts.tableName || 'RateLimiterFlexible';\n    this.prismaClient = opts.storeClient;\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout || true;\n\n    if (!this.prismaClient) {\n      throw new Error('Prisma client is not provided');\n    }\n\n    if (this.clearExpiredByTimeout) {\n      this._clearExpiredHourAgo();\n    }\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n\n    let doc = result;\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null\n      ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.prismaClient) {\n      return Promise.reject(new Error('Prisma client is not established'));\n    }\n\n    const now = new Date();\n    const newExpire = msDuration > 0 ? new Date(now.getTime() + msDuration) : null;\n\n    return this.prismaClient.$transaction(async (prisma) => {\n      const existingRecord = await prisma[this.modelName].findFirst({\n        where: { key: key },\n      });\n\n      if (existingRecord) {\n        // Determine if we should update the expire field\n        const shouldUpdateExpire = forceExpire || !existingRecord.expire || existingRecord.expire <= now || newExpire === null;\n\n        return prisma[this.modelName].update({\n          where: { key: key },\n          data: {\n            points: !shouldUpdateExpire ? existingRecord.points + points : points,\n            ...(shouldUpdateExpire && { expire: newExpire }),\n          },\n        });\n      } else {\n        return prisma[this.modelName].create({\n          data: {\n            key: key,\n            points: points,\n            expire: newExpire,\n          },\n        });\n      }\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.prismaClient) {\n      return Promise.reject(new Error('Prisma client is not established'));\n    }\n\n    return this.prismaClient[this.modelName].findFirst({\n      where: {\n        AND: [\n          { key: rlKey },\n          {\n            OR: [\n              { expire: { gt: new Date() } },\n              { expire: null },\n            ],\n          },\n        ],\n      },\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.prismaClient) {\n      return Promise.reject(new Error('Prisma client is not established'));\n    }\n\n    return this.prismaClient[this.modelName].deleteMany({\n      where: {\n        key: rlKey,\n      },\n    }).then(res => res.count > 0);\n  }\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(async () => {\n      await this.prismaClient[this.modelName].deleteMany({\n        where: {\n          expire: {\n            lt: new Date(Date.now() - 3600000),\n          },\n        },\n      });\n      this._clearExpiredHourAgo();\n    }, 300000); // Clear every 5 minutes\n  }\n}\n\nmodule.exports = RateLimiterPrisma;\n", "const RateLimiterRedis = require('./lib/RateLimiterRedis');\nconst RateLimiterMongo = require('./lib/RateLimiterMongo');\nconst RateLimiterMySQL = require('./lib/RateLimiterMySQL');\nconst RateLimiterPostgres = require('./lib/RateLimiterPostgres');\nconst {RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster} = require('./lib/RateLimiterCluster');\nconst RateLimiterMemory = require('./lib/RateLimiterMemory');\nconst RateLimiterMemcache = require('./lib/RateLimiterMemcache');\nconst RLWrapperBlackAndWhite = require('./lib/RLWrapperBlackAndWhite');\nconst RateLimiterUnion = require('./lib/RateLimiterUnion');\nconst RateLimiterQueue = require('./lib/RateLimiterQueue');\nconst BurstyRateLimiter = require('./lib/BurstyRateLimiter');\nconst RateLimiterRes = require('./lib/RateLimiterRes');\nconst RateLimiterDynamo = require('./lib/RateLimiterDynamo');\nconst RateLimiterPrisma = require('./lib/RateLimiterPrisma');\n\nmodule.exports = {\n  RateLimiterRedis,\n  RateLimiterMongo,\n  RateLimiterMySQL,\n  RateLimiterPostgres,\n  RateLimiterMemory,\n  RateLimiterMemcache,\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster,\n  RLWrapperBlackAndWhite,\n  RateLimiterUnion,\n  RateLimiterQueue,\n  BurstyRateLimiter,\n  RateLimiterRes,\n  RateLimiterDynamo,\n  RateLimiterPrisma,\n};\n"],
  "mappings": "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",
  "names": ["key", "require_BlockedKeys"]
}
